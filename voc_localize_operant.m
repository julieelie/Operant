function [Voc_filename,Voc_samp_idx,Voc_transc_time] = voc_localize_operant(RawWav_dir, Subj, Date, ExpStartTime, varargin)
%% VOC_LOCALIZE_OPERANT a function to retrieve the position of detected vocalizations by vocOperant in continuous recordings
% Inputs
% Voc_dir is the folder containing the vocalization extracts to identify

% RawWav_dir is the folder containing the continuous recordings and the
% file *TTLPulseTimes.mat generated by align_soundmexAudio_2_logger.m
% in case calculating transceiver time is requested

% 'TransceiverTime' (optional input): set by default to 1 to calculate the
% onset anf offset of sound extracts in transceiver time

% Ouputs
% Voc_filename is the file list of manual extracts 

% Voc_samp_idx is a 2 column vector that gives the onset and offset indices
% of each extract in the original recordings, same number of lines as
% Voc_filename

% Voc_transc_time is a 2 column vector that gives the expected onset and offest
% times of each extract in the piezo logger recordings in transceiver time,
% in ms
% same number of lines as Voc_filename.

%% Load data and initialize output variables
% Get input arguments
Pnames = {'TransceiverTime'};
TranscTime = 1; % Logical to indicate if transceiver time should be calculated for these extracts.
Dflts  = {TranscTime};
[TranscTime] = internal.stats.parseArgs(Pnames,Dflts,varargin{:});

if TranscTime
    % Load the pulse times and samples
    TTL_dir = dir(fullfile(RawWav_dir,sprintf( '%s_%s_TTLPulseTimes.mat', Date, ExpStartTime)));
    TTL = load(fullfile(TTL_dir.folder, TTL_dir.name));
end

% List of first sample of detected vocalizations
% Get the sample stamp of the detected vocalizations
DataFileStruc = dir(fullfile(RawWav_dir, sprintf('%s_%s_%s*events.txt', Subj, Date, ExpStartTime)));
Fid_Data = fopen(fullfile(DataFileStruc.folder,DataFileStruc.name));
EventsHeader = textscan(Fid_Data, '%s\t%s\t%s\t%s\t%s\t%s\t%s\n',1);
for hh=1:length(EventsHeader)
    if strfind(EventsHeader{hh}{1}, 'SampleStamp')
        EventsStampCol = hh;
    elseif strfind(EventsHeader{hh}{1}, 'Type')
        EventsEventTypeCol = hh;
    end
end
Events = textscan(Fid_Data, '%s\t%f\t%s\t%s\t%f\t%f\t%f');
fclose(Fid_Data);
VocId = find(strcmp('Vocalization', Events{EventsEventTypeCol}));
FullStamps = Events{EventsStampCol}(VocId);

% initialize variables
NVoc = length(AllVocs);
Voc_filename = cell(NVoc,1);
Voc_samp_idx = nan(NVoc,2);
Voc_transc_time = nan(NVoc,2);

% Get the duration of all raw recordings
Length_Y = get_raw_file_length(AudioDataPath, Subj, Date, ExpStartTime);

% We choose to have 500ms of recording before and after sound detection onset
% to better isolate the vocalization
Buffer_s = 0.5;

    
    for ss=1:length(FullStamps)
        Ind_ = strfind(FullStamps{ss}, '_');
        Seq = str2double(FullStamps{ss}(1:(Ind_-1)));
        Stamp = str2double(FullStamps{ss}((Ind_+1):end));
        if Stamp<0
            Stamp = 2*2147483647 + Stamp; % Correcion of soundmexpro bug that coded numbers in 32 bits instead of 64bits
        end
    
        % Get the recording data for the corresponding sequence
        WavFileStruc_local = dir(fullfile(RawWav_dir, sprintf('%s*mic*_%d.wav',DataFile(1:16), Seq)));
        try
            Wavefile_local = fullfile(WavFileStruc_local.folder, WavFileStruc_local.name);
            [Y,FS] = audioread(Wavefile_local);
            Buffer = Buffer_s*FS;
        catch
            fprintf(1,'Warning: the audiofile %s cannot be read properly!!\n', Wavefile_local);
            Y = 0;
        end
        Y_section_beg = max(1,Stamp - sum(Length_Y(1:(Seq-1))) - Buffer); % Make sure we don't request before the beginning of the raw wave file
        Pre_stamp = min(Buffer, Stamp - sum(Length_Y(1:(Seq-1)))); % Length of the sound section before sound detection onset
        Y_section_end = min(length(Y), Stamp - sum(Length_Y(1:(Seq-1))) + Buffer); % Make sure we don't request after the end of the aw wave file
        Post_stamp = min(Buffer, length(Y)- (Stamp - sum(Length_Y(1:(Seq-1)))));% Length of the sound section after sound detection onset
        Y_section = Y(Y_section_beg:Y_section_end);
        
        % calculate the envelpe of that extract and cut it when the
        % enveloppe gets lower than 10% of the max
        
    
    % Plot the waveforms of the recording around the stamp of the vocalization
    figure(2)
    cla
    plot(Y_section, 'Color', 'k')

%% Loop through extracts and localize them
for vv=1:NVoc
    fprintf('vocalization %d/%d\n',vv, NVoc);
    % load the extract
    Voc_filename{vv} = fullfile(AllVocs(vv).folder, AllVocs(vv).name);
    [Voc_wav] = audioread(Voc_filename{vv});
    
    % load the raw file
    Idx_ = strfind(AllVocs(vv).name, '_');
    if VocOp
        IdxSnip = strfind(AllVocs(vv).name, 'snipfile');
        Raw_filename = fullfile(RawWav_dir, [AllVocs(vv).name(1:(IdxSnip-1)) 'mic1' AllVocs(vv).name(IdxSnip+(8:10)) '.wav']);
    else
        Raw_filename = fullfile(RawWav_dir, [AllVocs(vv).name(1:(Idx_(end)-1)) '.wav']);
    end
    Raw_wav = audioread(Raw_filename);
    % Identify raw file index
    FileIdx = str2double(AllVocs(vv).name((Idx_(end-1)+1):(Idx_(end)-1)));
    
    
    % Find the localization of the extract in
    % the raw file
    Voc_samp_idx(vv,1) = strfind(Raw_wav', Voc_wav');
    Voc_samp_idx(vv,2) = Voc_samp_idx(vv,1) + length(Voc_wav);
     
    % if requested plot the result of the cross-crrelation
    Buffer = 1000;
    Raw_extract = Raw_wav((Voc_samp_idx(vv,1)-Buffer):(Voc_samp_idx(vv,2)+Buffer));
    plot(Raw_extract, 'k-', 'LineWidth',2);
    hold on
    plot(Buffer+(1:length(Voc_wav)), Voc_wav, 'r-')
    line([Buffer Buffer],[min(Voc_wav) max(Voc_wav)])
    hold off
    legend({'Raw recording', 'extract'})
    pause(1)
    
    if TranscTime
        % Extract the transceiver time 
        % zscore the sample stamps
        TTL_idx = find(unique(TTL.File_number) == FileIdx);
        Voc_samp_idx_zs = (Voc_samp_idx(vv,:) - TTL.Mean_std_Pulse_samp_audio(TTL_idx,1))/TTL.Mean_std_Pulse_samp_audio(TTL_idx,2);
        % calculate the transceiver times
        Voc_transc_time(vv,:) = TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,2) .* polyval(TTL.Slope_and_intercept{TTL_idx},Voc_samp_idx_zs,[], TTL.Mean_std_x{TTL_idx}) + TTL.Mean_std_Pulse_TimeStamp_Transc(TTL_idx,1);  
    end
end

%% save the calculation results
if TranscTime
    save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx','Voc_transc_time')
else
    save(fullfile(RawWav_dir, sprintf('%s_%s_VocExtractTimes.mat', Date, ExpStartTime)), 'Voc_filename','Voc_samp_idx')
end
end

